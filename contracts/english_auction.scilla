scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)
import BoolUtils IntUtils

library EnglishAuctionOrderbook

let zero_address = 0x0000000000000000000000000000000000000000
let zero_uint128 = Uint128 0
let one_uint128 = Uint128 1
let false = False
let true = True

let min_fee_bps = Uint128 1
let max_fee_bps = Uint128 10000

let one_msg = 
  fun (msg : Message) => 
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let get_bal =
  fun (maybe_bal: Option Uint128) =>
    match maybe_bal with
    | None => zero_uint128
    | Some bal => bal
    end
      
let portion = 
  fun(amount: Uint128) =>
  fun(bps: Uint128) => 
    (* To avoid integer overflow, use division only. *)
    (* amount / ( 10000 / bps ) *)
    (* bps ranges from 1 to 10000. *)
    let max_bps = Uint128 10000 in
    let x = builtin div max_bps bps in
    (* x ranges from 1 to 10000. *)
    let result = builtin div amount x in
    result

let option_value =
  tfun 'A =>
  fun (default: 'A) =>
  fun (opt_val: Option 'A) =>
    match opt_val with
    | Some v => v
    | None => default
    end

let option_address = @option_value ByStr20

(* maker, expiration block number, payment_token_address, start amount *)
type SellOrder = 
| SellOrder of ByStr20 BNum ByStr20 Uint128

(* maker, amount, dest, bid count *)
type BuyOrder = 
| BuyOrder of ByStr20 Uint128 ByStr20 Uint128

(* Error exceptions *)
type Error =
  | SellOrderNotFoundError
  | SellOrderFoundError
  | BuyOrderNotFoundError
  | NotSpenderError
  | NotTokenOwnerError
  | NotSelfError
  | LessThanMinBidError
  | InsufficientAllowanceError
  | NotExpiredError
  | ExpiredError
  | AccountNotFoundError
  | InsufficientPaymentTokenError
  | AssetNotFoundError
  | NotAllowedToEndError
  | NotAllowedPaymentToken
  | NotPausedError
  | PausedError
  | NotContractOwnerError
  | InvalidFeeBPSError
  
let make_error =
  fun (result : Error) =>
    let result_code = 
      match result with
      | SellOrderNotFoundError              => Int32 -1
      | SellOrderFoundError                 => Int32 -2
      | BuyOrderNotFoundError               => Int32 -3
      | NotSpenderError                     => Int32 -4
      | NotTokenOwnerError                  => Int32 -5
      | NotSelfError                        => Int32 -6
      | LessThanMinBidError                 => Int32 -7
      | InsufficientAllowanceError          => Int32 -8
      | NotExpiredError                     => Int32 -9
      | ExpiredError                        => Int32 -10
      | AccountNotFoundError                => Int32 -11
      | InsufficientPaymentTokenError       => Int32 -12
      | AssetNotFoundError                  => Int32 -13
      | NotAllowedToEndError                => Int32 -14
      | NotAllowedPaymentToken              => Int32 -15
      | NotPausedError                      => Int32 -16
      | PausedError                         => Int32 -17
      | NotContractOwnerError               => Int32 -18
      | InvalidFeeBPSError                  => Int32 -14
      end
    in
    { _exception : "Error"; code : result_code }

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract EnglishAuctionOrderbook
(
  initial_contract_owner: ByStr20,
  wzil_address: ByStr20
)

(* Contract Owner *)
(* Defaults to `initial_contract_owner` *)
field contract_owner: ByStr20 = initial_contract_owner

(* Emergency stop mechanism *)
(* Defaults to False *)
field is_paused: Bool = false

(* We assume all orders are english auction type  *)
(* 
  A composite primary key of a sell order consists of
  - asset contract address (ZRC-6)
  - token ID
*)

(* token_address -> ( token_id -> order ) *)
field sell_orders: Map ByStr20 (Map Uint256 SellOrder) = Emp ByStr20 (Map Uint256 SellOrder)
field buy_orders: Map ByStr20 (Map Uint256 BuyOrder) = Emp ByStr20 (Map Uint256 BuyOrder)

(* owner -> ( token_address -> token set ) *)
field assets: Map ByStr20 (Map ByStr20 (Map Uint256 Bool)) = Emp ByStr20 (Map ByStr20 (Map Uint256 Bool))

(* owner -> ( payment_token_address -> amount ) *)
field payment_tokens: Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)

(* There must be an allowlist for the payment tokens (ZRC-2) *)
field allowed_payment_tokens: Map ByStr20 Bool =
let emp_map = Emp ByStr20 Bool in
builtin put emp_map wzil_address true

(* service fee BPS (e.g. 250 = 2.5% *)
(* A marketplace may take service fee (x% of every transaction) and use basis points (BPS) for the fee.  *)
(* `service_fee_bps` must range from `1` to `10000`. *)
(* Defaults to 250 *)
field service_fee_bps: Uint128 = Uint128 250

field service_fee_recipient: ByStr20 = initial_contract_owner

(* Procedures *)
procedure Throw(error : Error)
  e = make_error error;
  throw e
end

procedure RequireValidFeeBPS(fee_bps: Uint128)
  is_gte_min = uint128_ge fee_bps min_fee_bps;
  is_lte_max = uint128_le fee_bps max_fee_bps;
  
  is_valid = andb is_gte_min is_lte_max;
  match is_valid with 
    | True => 
    | False =>
      error = InvalidFeeBPSError;
      Throw error
  end
end

procedure RequireContractOwner()
  cur_owner <- contract_owner;
  is_contract_owner = builtin eq cur_owner _sender;
  match is_contract_owner with
  | True => 
  | False =>
    error = NotContractOwnerError;
    Throw error
  end
end

procedure RequireSelf(x: ByStr20)
  is_self = builtin eq x _sender;
  match is_self with
  | True =>
  | False =>
    error = NotSelfError;
    Throw error
  end
end

procedure RequireNotPaused()
  (* Reference: *)
  (* https://consensys.github.io/smart-contract-best-practices/general_philosophy/#prepare-for-failure *)
  paused <- is_paused;
  match paused with
  | False =>
  | True =>
    (* Contract is paused *)
    error = PausedError;
    Throw error
  end
end

procedure RequireAllowedPaymentToken(payment_token_address: ByStr20)
  is_zero_address = builtin eq payment_token_address zero_address;
  is_zero_amount = builtin eq _amount zero_uint128;
  has_amount = negb is_zero_amount;
  
  is_native_zil = andb has_amount is_zero_address;
  is_allowed_zrc2_address <- exists allowed_payment_tokens[payment_token_address];

  is_allowed = orb is_native_zil is_allowed_zrc2_address;
  match is_allowed with
  | True =>
  | False =>
    error = NotAllowedPaymentToken;
    Throw error
  end
end

procedure RequireNotExpired(expiration_bnum: BNum)
  cur_bnum <- & BLOCKNUMBER;  
  is_not_expired = builtin blt cur_bnum expiration_bnum;
  match is_not_expired with
  | True =>
  | False =>
    error = ExpiredError;
    Throw error
  end
end

procedure RequireExpired(expiration_bnum: BNum)
  cur_bnum <- & BLOCKNUMBER;  
  is_not_expired = builtin blt cur_bnum expiration_bnum;
  match is_not_expired with
  | False =>
  | True =>
    error = NotExpiredError;
    Throw error
  end
end

procedure RequireSenderToBeTokenOwner(token_address: ByStr20 with contract field token_owners: Map Uint256 ByStr20 end, token_id: Uint256)
  opt_token_owner <- & token_address.token_owners[token_id];
  token_owner = option_address zero_address opt_token_owner;
  is_token_owner = builtin eq _sender token_owner;
  match is_token_owner with
  | True =>
  | False =>
    error = NotTokenOwnerError;
    Throw error
  end
end

procedure RequireThisToBeSpender(token_address: ByStr20 with contract field spenders: Map Uint256 ByStr20 end, token_id: Uint256)
  (* A marketplace must be a spender and temporarily lock up ZRC-2, ZRC-6 tokens by holding them. *)
  opt_spender <- & token_address.spenders[token_id];
  spender = option_address zero_address opt_spender;
  is_spender = builtin eq _this_address spender;
  match is_spender with
  | True =>
  | False =>
    error = NotSpenderError;
    Throw error
  end
end

procedure AddToPaymentTokenBalance(to: ByStr20, payment_token_address: ByStr20, amount: Uint128)
  maybe_bal <- payment_tokens[to][payment_token_address];
  
  new_bal = 
    let cur_bal = get_bal maybe_bal in
    (* if underflow occurs, it throws CALL_CONTRACT_FAILED *)
    builtin add cur_bal amount;
    
  payment_tokens[to][payment_token_address] := new_bal
end

procedure TransferNativeZILs(to: ByStr20, amount: Uint128)
  msg = {
    _tag: "TransferNativeZILs";
    _recipient: to;
    _amount: amount
  };
  msgs = one_msg msg;
  send msgs
end
        
procedure ZRC2Transfer(payment_token_address: ByStr20, to: ByStr20, amount: Uint128)
  msg_to_wzil = {
    _tag: "Transfer";
    _recipient: payment_token_address;
    _amount: Uint128 0;
    to: to;
    amount: amount
  };
  msgs = one_msg msg_to_wzil;
  send msgs
end

procedure ZRC2TransferFrom(payment_token_address: ByStr20, from: ByStr20, to: ByStr20, amount: Uint128)
  msg_to_wzil = {
    _tag: "TransferFrom";
    _recipient: payment_token_address;
    _amount: Uint128 0;
    from: from;
    to: to;
    amount: amount
  };
  msgs = one_msg msg_to_wzil;
  send msgs
end

procedure ZRC6TransferFrom(token_address: ByStr20, to: ByStr20, token_id: Uint256)
  msg_to_zrc6 = {
    _tag: "TransferFrom";
    _recipient: token_address;
    _amount: Uint128 0;
    to: to;
    token_id: token_id
  };
  msgs = one_msg msg_to_zrc6;
  send msgs
end

procedure BidWithNativeZILs(
  token_address: ByStr20 with contract 
    field royalty_recipient: ByStr20, 
    field royalty_fee_bps: Uint128, 
    field spenders: Map Uint256 ByStr20, 
    field token_owners: Map Uint256 ByStr20 
  end,
  token_id: Uint256,
  start_amount: Uint128,
  dest: ByStr20
)
  amount = _amount;

  (* Check this bid is the first bid *)
  maybe_buy_order <- buy_orders[token_address][token_id];
  match maybe_buy_order with 
  | None =>
    (* Check if the new amount gte start_amount *)
    is_less_than_start_amount = builtin lt amount start_amount;
    match is_less_than_start_amount with
    | True =>
      error = LessThanMinBidError;
      Throw error
    | False =>
      (* Create a buy order *)
      new_order = BuyOrder _sender amount dest one_uint128;
      buy_orders[token_address][token_id] := new_order
    end
  | Some (BuyOrder old_buyer cur_amount cur_dest bid_count) =>
    (* We have the existing bid. We track the max only. *)
    (* Minimum Bid = Current Bid + Bid Increment *)

    (* Calculate min bid *)
    ten_percent = Uint128 1000;
    bid_increment = portion cur_amount ten_percent;
    min_bid = builtin add cur_amount bid_increment;

    is_less_than_min_bid = builtin lt amount min_bid;
    match is_less_than_min_bid with
    | True => 
      error = LessThanMinBidError;
      Throw error
    | False =>      
      (* markekplace pays back the old bider the current amount *)
      (* Use zero address for native ZILs *)
      AddToPaymentTokenBalance old_buyer zero_address cur_amount;

      (* Update the buy order with new buyer *)
      new_bid_count = builtin add bid_count one_uint128;
      new_order = BuyOrder _sender amount dest new_bid_count;
      buy_orders[token_address][token_id] := new_order
    end
  end
end

procedure BidWithZRC2(
  token_address: ByStr20 with contract 
    field royalty_recipient: ByStr20, 
    field royalty_fee_bps: Uint128, 
    field spenders: Map Uint256 ByStr20, 
    field token_owners: Map Uint256 ByStr20 
  end,
  token_id: Uint256,
  payment_token_address: ByStr20 with contract 
    field allowances: Map ByStr20 (Map ByStr20 Uint128)
  end,
  amount: Uint128,
  start_amount: Uint128,
  dest: ByStr20
)
  (* Check this marketplace is the spender *)
  maybe_bal <- & payment_token_address.allowances[_sender][_this_address];
  match maybe_bal with
  | None =>
    (* This Marketplace is not the spender *)
    error = NotSpenderError;
    Throw error
  | Some bal =>
    (* Check this marketplace has sufficient allowance *)
    is_insufficient = builtin lt bal amount;
    match is_insufficient with
    | True => 
      (* This marketplace has insufficient allowance *)
      error = InsufficientAllowanceError;
      Throw error  
    | False => 
      (* This marketplace have the sufficient allowance *)
      (* Lock up the payment tokens *)
      ZRC2TransferFrom payment_token_address _sender _this_address amount; 

      (* Check this bid is the first bid *)
      maybe_buy_order <- buy_orders[token_address][token_id];
      match maybe_buy_order with 
      | None =>
        (* Check if the new amount gte start_amount *)
        is_less_than_start_amount = builtin lt amount start_amount;
        match is_less_than_start_amount with
        | True =>
          error = LessThanMinBidError;
          Throw error
        | False =>
          (* Create a buy order *)
          new_order = BuyOrder _sender amount dest one_uint128;
          buy_orders[token_address][token_id] := new_order
        end
      | Some (BuyOrder old_buyer cur_amount cur_dest bid_count) =>
        (* We have the existing bid. We track the max only. *)
        (* Minimum Bid = Current Bid + Bid Increment *)

        (* Calculate min bid *)
        ten_percent = Uint128 1000;
        bid_increment = portion cur_amount ten_percent;
        min_bid = builtin add cur_amount bid_increment;
        
        is_less_than_min_bid = builtin lt amount min_bid;
        match is_less_than_min_bid with
        | True => 
          error = LessThanMinBidError;
          Throw error
        | False =>      
          (* markekplace pays back the old bider the current amount *)
          AddToPaymentTokenBalance old_buyer payment_token_address cur_amount;

          (* Update the buy order with new buyer *)
          new_bid_count = builtin add bid_count one_uint128;
          new_order = BuyOrder _sender amount dest new_bid_count;
          buy_orders[token_address][token_id] := new_order
        end
      end
    end
  end
end

(* Pauses the contract. Use this when things are going wrong ('circuit breaker'). *)
(* @Requirements: *)
(* - The contract must not be paused. Otherwise, it must throw `PausedError` *)
(* - `_sender` must be the contract owner. Otherwise, it must throw `NotContractOwnerError` *)
transition Pause()
  RequireNotPaused;
  RequireContractOwner;

  is_paused := true;
  e = {
    _eventname: "Pause";
    is_paused: true
  };
  event e
end

(* Unpauses the contract. *)
(* @Requirements: *)
(* - The contract must be paused. Otherwise, it must throw `NotPausedError` *)
(* - `_sender` must be the contract owner. Otherwise, it must throw `NotContractOwnerError` *)
transition Unpause()
  paused <- is_paused;
  match paused with
  | True =>
  | False =>
    error = NotPausedError;
    Throw error
  end;
  RequireContractOwner;

  is_paused := false;
  e = {
    _eventname: "Unpause";
    is_paused: false
  };
  event e
end

transition Start(
  token_address: ByStr20 with contract 
    field royalty_recipient: ByStr20, 
    field royalty_fee_bps: Uint128, 
    field spenders: Map Uint256 ByStr20, 
    field token_owners: Map Uint256 ByStr20  
  end,
  token_id: Uint256,
  payment_token_address: ByStr20,
  start_amount: Uint128,
  expiration_bnum: BNum
  )
  (* 
    - Seller can start an auction for an asset only if the asset has no ongoing auction. 
  *)
  RequireNotPaused;
  RequireNotExpired expiration_bnum;
  RequireAllowedPaymentToken payment_token_address;

  has_sell_order <- exists sell_orders[token_address][token_id];
  match has_sell_order with 
  | True => 
    (* It's already listed *)
    error = SellOrderFoundError;
    Throw error
  | False => 
    RequireSenderToBeTokenOwner token_address token_id;
    RequireThisToBeSpender token_address token_id;
    (* lock up token by holding it *)
    ZRC6TransferFrom token_address _this_address token_id;

    (* create a sell order *)
    new_order = SellOrder _sender expiration_bnum payment_token_address start_amount;
    sell_orders[token_address][token_id] := new_order
  end;
  
  e = {
    _eventname : "Start";
    maker: _sender;
    token_address: token_address;
    token_id: token_id;
    payment_token_address: payment_token_address;
    start_amount: start_amount;
    expiration_bnum: expiration_bnum
  };
  event e
end

transition Bid(
  token_address: ByStr20 with contract 
    field royalty_recipient: ByStr20, 
    field royalty_fee_bps: Uint128, 
    field spenders: Map Uint256 ByStr20, 
    field token_owners: Map Uint256 ByStr20 
  end,
  token_id: Uint256,
  amount: Uint128,
  dest: ByStr20
  )
  (* 
    - Bidders can bid for an existing auction.
    - A bid must not be less than start amount of the auction.
    - A bid must not be less than the minimum bid (Minimum Bid = Current Bid + Bid Increment).
    - We assume that the bid increment is 10% of the current bid.
    - Bidders must be able to set an address to receive the asset when creating a buy order.
    - If the current bid is updated, the previous bidder can withdraw the payment tokens back. 
  *)
  RequireNotPaused;
  
  (* Check the sell order does exist *)
  maybe_sell_order <- sell_orders[token_address][token_id];
  match maybe_sell_order with 
  | None =>
    (* Sell order doesn't exist *)
    error = SellOrderNotFoundError;
    Throw error
  | Some (SellOrder seller expiration_bnum payment_token_address start_amount) =>
    (* Check the sell order is not expired *)
    RequireNotExpired expiration_bnum;

    (* It's native ZIL case if the payment_token_address is zero address and amount is 0 *)
    is_zero_address = builtin eq payment_token_address zero_address;
    is_amount_zero = builtin eq amount zero_uint128;
    is_native_zil = andb is_amount_zero is_zero_address;
    
    match is_native_zil with 
    | True => 
      accept;
      BidWithNativeZILs token_address token_id start_amount dest;
      e = {
        _eventname : "Bid";
        maker: _sender;
        token_address: token_address;
        token_id: token_id;
        amount: _amount;
        dest: dest
      };
      event e
    | False =>
      maybe_zrc2_token_address <- & payment_token_address as ByStr20 with contract 
        field allowances: Map ByStr20 (Map ByStr20 Uint128)
      end;

      match maybe_zrc2_token_address with 
      | None => 
        error = NotAllowedPaymentToken;
        Throw error
      | Some zrc2_token_address => 
        BidWithZRC2 token_address token_id zrc2_token_address amount start_amount dest;

        e = {
          _eventname : "Bid";
          maker: _sender;
          token_address: token_address;
          token_id: token_id;
          amount: amount;
          dest: dest
        };
        event e
      end
    end
  end
end

transition Cancel(
  token_address: ByStr20 with contract 
    field royalty_recipient: ByStr20, 
    field royalty_fee_bps: Uint128, 
    field spenders: Map Uint256 ByStr20, 
    field token_owners: Map Uint256 ByStr20 
  end,
  token_id: Uint256
  )
  RequireNotPaused;

  (* Check the sell order does exist *)
  maybe_sell_order <- sell_orders[token_address][token_id];
  match maybe_sell_order with 
  | None =>
    (* Sell order doesn't exist *)
    error = SellOrderNotFoundError;
    Throw error
  | Some (SellOrder seller expiration_bnum payment_token_address start_amount)  => 
    (* Check the sell order is not expired *)
    RequireNotExpired expiration_bnum;
    (* Only seller must be able to cancel the sell order *)
    RequireSelf seller;

    (* Asset for the seller  *)
    assets[seller][token_address][token_id] := true;
    delete sell_orders[token_address][token_id];
    
    (* Check if the buy order exist *)
    maybe_buy_order <- buy_orders[token_address][token_id];
    match maybe_buy_order with 
    | None =>
      (* noop *)
    | Some (BuyOrder buyer cur_amount buy_dest _) =>  
      (* markekplace pays back the old bider the current amount *)
      AddToPaymentTokenBalance buyer payment_token_address cur_amount;
      delete buy_orders[token_address][token_id]
    end;
    e = {
      _eventname : "Cancel";
      token_address: token_address;
      token_id: token_id
    };
    event e
  end
end

transition End(
  token_address: ByStr20 with contract 
    field royalty_recipient: ByStr20, 
    field royalty_fee_bps: Uint128, 
    field spenders: Map Uint256 ByStr20, 
    field token_owners: Map Uint256 ByStr20 
  end,
  token_id: Uint256
  )
  (* 
    - Seller, buyer, or admin can end the auction only after the sell order has been expired.
    - When an auction is ended, the buyer can withdraw the asset
    - When an auction is ended, the seller can withdraw get the payment tokens.
  *)
  RequireNotPaused;

  (* Check the sell order does exist *)
  maybe_sell_order <- sell_orders[token_address][token_id];
  match maybe_sell_order with 
  | None =>
    (* Sell order doesn't exist *)
    error = SellOrderNotFoundError;
    Throw error
  | Some (SellOrder seller expiration_bnum payment_token_address start_amount)  => 
    (* Check the sell order is expired *)
    RequireExpired expiration_bnum;

    (* Check the buy order does exist *)
    maybe_buy_order <- buy_orders[token_address][token_id];
    match maybe_buy_order with 
    | None =>
      (* Buy order doesn't exist *)
      error = BuyOrderNotFoundError;
      Throw error
    | Some (BuyOrder buyer sale_price buy_dest _) =>

      (* Check _sender is the seller or the buyer *)
      is_seller = builtin eq _sender seller;
      is_buyer = builtin eq _sender buyer;
      
      is_seller_or_buyer = orb is_seller is_buyer;
      match is_seller_or_buyer with
      | False => 
        (* Buy order doesn't exist *)
        error = NotAllowedToEndError;
        Throw error
      | True => 
        (* Calculate royalty amount *)
        royalty_fee_bps <- & token_address.royalty_fee_bps;
        royalty_amount = portion sale_price royalty_fee_bps;

        (* Calculate service fee *)
        fee_bps <- service_fee_bps;
        service_fee = portion sale_price fee_bps;

        (* Calculate seller profit *)
        profit = builtin sub sale_price royalty_amount;
        seller_profit = builtin sub profit service_fee;

        royalty_recipient <- & token_address.royalty_recipient;
        seller_fee_recipient <- service_fee_recipient;

        (* It's native ZIL case if the payment_token_address is zero address *)
        is_zero_address = builtin eq payment_token_address zero_address;
        
        match is_zero_address with 
        | True => 
          (* marketplace transfers royalty fee to the royalty_recipient; *)
          TransferNativeZILs royalty_recipient royalty_amount;

          (* marketplace transfers service fee to this marketplace owner *)
          TransferNativeZILs seller_fee_recipient service_fee
        | False => 
          (* marketplace transfers royalty fee to the royalty_recipient; *)
          ZRC2Transfer payment_token_address royalty_recipient royalty_amount;

          (* marketplace transfers service fee to this marketplace owner *)
          ZRC2Transfer payment_token_address seller_fee_recipient service_fee
        end;
        
        (* Asset for buy_dest *)
        assets[buy_dest][token_address][token_id] := true;
        
        (* payment tokens for the seller *)
        AddToPaymentTokenBalance seller payment_token_address seller_profit;

        (* Cleanup orders *)
        delete sell_orders[token_address][token_id];
        delete buy_orders[token_address][token_id];

        e = {
          _eventname : "End";
          token_address: token_address;
          token_id: token_id;
          payment_token_address: payment_token_address;
          sale_price: sale_price;
          seller: seller;
          buyer: buyer;
          asset_recipient: buy_dest;
          payment_tokens_recipient: seller;
          royalty_recipient: royalty_recipient;
          royalty_amount: royalty_amount;
          service_fee: service_fee
        };
        event e
      end
    end
  end
end

transition WithdrawPaymentTokens(payment_token_address: ByStr20, amount: Uint128)
  (* - Anyone who has payment tokens can draw their tokens. *)
  RequireNotPaused;

  maybe_balance <- payment_tokens[_sender][payment_token_address];
  match maybe_balance with
  | None =>
    error = AccountNotFoundError;
    Throw error
  | Some balance =>
    is_insufficient = builtin lt balance amount;
    match is_insufficient with 
    | True => 
      error = InsufficientPaymentTokenError;
      Throw error
    | False => 

      is_native_zil = builtin eq payment_token_address zero_address;
      match is_native_zil with
      | True =>
        (* marketplace transfers the native ZILs to _sender *)
        TransferNativeZILs _sender amount
      | False => 
        (* marketplace transfers the amount to _sender *)
        ZRC2Transfer payment_token_address _sender amount
      end;

      left = builtin sub balance amount;
      payment_tokens[_sender][payment_token_address] := left;
      e = {
        _eventname : "WithdrawPaymentTokens";
        recipient: _sender;
        payment_token_address: payment_token_address;
        amount: amount
      };
      event e
    end
  end
end

transition WithdrawAsset(token_address: ByStr20, token_id: Uint256)
  (* - Anyone who has assets can draw their asset. *)
  
  RequireNotPaused;
  
  has_token <- exists assets[_sender][token_address][token_id];
  match has_token with
  | False =>
    error = AssetNotFoundError;
    Throw error
  | True =>
    (* marketplace transfers the zrc6 token to buyer *)
    ZRC6TransferFrom token_address _sender token_id;
    
    delete assets[_sender][token_address][token_id];

    e = {
      _eventname : "WithdrawAsset";
      recipient: _sender;
      token_address: token_address;
      token_id: token_id
    };
    event e
  end
end

transition SetServiceFeeBPS(fee_bps: Uint128)
  RequireContractOwner;
  RequireValidFeeBPS fee_bps;
  service_fee_bps := fee_bps;
  e = {
    _eventname : "SetServiceFeeBPS";
    service_fee_bps: fee_bps
  };
  event e
end

(* empty callbacks *)
transition ZRC6_RecipientAcceptTransferFrom(from: ByStr20, to: ByStr20, token_id: Uint256)
end
transition ZRC6_TransferFromCallback(from:ByStr20, to: ByStr20, token_id: Uint256)
end
transition RecipientAcceptTransferFrom(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
end
transition TransferSuccessCallBack(sender: ByStr20, recipient: ByStr20, amount: Uint128)
end
transition TransferFromSuccessCallBack(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
end
