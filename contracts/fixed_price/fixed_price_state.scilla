(* SPDX-License-Identifier: GPL-3.0 *)
scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)
import BoolUtils IntUtils

library FixedPriceOrderbook_State

let zero_address = 0x0000000000000000000000000000000000000000
let zero_uint32 = Uint32 0
let zero_uint128 = Uint128 0
let false = False
let true = True

let min_bps = Uint128 1
let max_bps = Uint128 10000

let sell_side = Uint32 0

let one_msg = 
  fun (msg : Message) => 
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let two_msgs =
fun (msg1: Message) =>
fun (msg2: Message) =>
  let msgs_tmp = one_msg msg2 in
  Cons {Message} msg1 msgs_tmp

let three_msgs =
fun (msg1: Message) =>
fun (msg2: Message) =>
fun (msg3: Message) =>
  let msgs_tmp = two_msgs msg2 msg3 in
  Cons {Message} msg1 msgs_tmp

let uint128_to_uint256 : Uint128 -> Uint256 =
  fun (x : Uint128) =>
    let ox256 = builtin to_uint256 x in
      match ox256 with
      | None =>
        (* this never happens, hence we throw a division by zero exception just in case *)
        let zero = Uint256 0 in
        builtin div zero zero
      | Some x256 => x256
      end

let portion = 
  fun(amount: Uint128) =>
  fun(bps: Uint128) => 
    let max_bps256 = uint128_to_uint256 max_bps in
    let amount256 = uint128_to_uint256 amount in
    let bps256 = uint128_to_uint256 bps in
    let x256 = builtin mul amount256 bps256 in
    let res256 = builtin div x256 max_bps256 in
    let ores128 = builtin to_uint128 res256 in
    match ores128 with
    | None =>
      zero_uint128
    | Some res128 =>
      res128
    end
  

let option_value =
  tfun 'A =>
  fun (default: 'A) =>
  fun (maybe_val: Option 'A) =>
    match maybe_val with
    | Some v => v
    | None => default
    end

let option_address = @option_value ByStr20
let option_uint32 = @option_value Uint32
let option_uint128 = @option_value Uint128

(* Computes the commission_fee if there is one. If not, it returns Uint128 0 *)
let compute_commission_fee = 
  fun(sale_price: Uint128) =>
  fun(opt_commission_fee_bps: Option Uint128) =>
  fun(maybe_has_had_first_sale: Bool) =>
    match maybe_has_had_first_sale with
      | True => 
        zero_uint128
      | False => 
        let brand_commission_fee = option_uint128 zero_uint128 opt_commission_fee_bps in
          portion sale_price brand_commission_fee
    end

(* maker, expiration block number *)
type Order = 
| Order of ByStr20 BNum

(* for batch transitions *)
(* token_address, token_id, payment_token_address, sale_price, side, expiration block number *)
type OrderParam =
| OrderParam of ByStr20 with contract 
field royalty_recipient: ByStr20, 
field royalty_fee_bps: Uint128, 
field spenders: Map Uint256 ByStr20, 
field token_owners: Map Uint256 ByStr20 
end Uint256 ByStr20 Uint128 Uint32 BNum

(* Error exceptions *)
type Error =
  | NotContractOwnerError
  | NotPausedError
  | PausedError
  | SelfError
  | NotContractOwnershipRecipientError
  | ZeroAddressError
  | NotOperatorError
  
let make_error =
  fun (result : Error) =>
    let result_code = 
      match result with
      | NotContractOwnerError              => Int32 -1
      | NotPausedError                     => Int32 -2
      | PausedError                        => Int32 -3
      | SelfError                          => Int32 -4
      | NotContractOwnershipRecipientError => Int32 -5
      | ZeroAddressError                   => Int32 -6
      | NotOperatorError                   => Int32 -7
      end
    in
    { _exception : "Error"; code : result_code }

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract FixedPriceOrderbook_State
(
  initial_contract_owner: ByStr20,
  initial_collection_contract: ByStr20 with contract
    field token_collection: Map ByStr20 (Map Uint256 Uint32),
    field collection_owning_brand: Map Uint32 ByStr20,
    field has_had_first_sale: Map ByStr20 (Map Uint256 Bool),
    field collection_commission_fee: Map Uint32 Uint128
  end
)

(* Logic Contract Address  *)
field logic: ByStr20 = zero_address

(* 
  A composite primary key of a sell order or buy order consists of
  - asset contract address (ZRC-6)
  - token ID
  - payment token contract address (ZRC-2)
  - sale price
*)

(* Allowlist Contract Address *)
(* Defaults to `zero_address` *)
field allowlist_address: ByStr20 = zero_address

(* Collection Contract Address *)
field collection_address: ByStr20 with contract
  field token_collection: Map ByStr20 (Map Uint256 Uint32),
  field collection_owning_brand: Map Uint32 ByStr20,
  field has_had_first_sale: Map ByStr20 (Map Uint256 Bool),
  field collection_commission_fee: Map Uint32 Uint128
end = initial_collection_contract

(* Contract Owner *)
(* Defaults to `initial_contract_owner` *)
field contract_owner: ByStr20 = initial_contract_owner

(* Contract ownership recipient *)
(* Defaults to `zero_address` *)
field contract_ownership_recipient: ByStr20 = zero_address

(* Emergency stop mechanism *)
(* Defaults to False *)
field is_paused: Bool = false

(* token_address -> ( token_id -> ( payment_token_address -> (sale_price -> sell_order  ) ) *)
field sell_orders: Map ByStr20 (Map Uint256 (Map ByStr20 (Map Uint128 Order))) = Emp ByStr20 (Map Uint256 (Map ByStr20 (Map Uint128 Order)))

(* token_address -> ( token_id -> ( payment_token_address -> (sale_price -> buy_order ) ) *)
field buy_orders: Map ByStr20 (Map Uint256 (Map ByStr20 (Map Uint128 Order))) = Emp ByStr20 (Map Uint256 (Map ByStr20 (Map Uint128 Order)))

(* There must be an allowlist for the payment tokens (ZRC-2) *)
field allowed_payment_tokens: Map ByStr20 Bool = Emp ByStr20 Bool

(* service fee BPS (e.g. 250 = 2.5% *)
(* A marketplace may take service fee (x% of every transaction) and use basis points (BPS) for the fee.  *)
(* `service_fee_bps` must range from `1` to `10000`. *)
(* Defaults to 250 *)
field service_fee_bps: Uint128 = Uint128 250

field service_fee_recipient: ByStr20 = initial_contract_owner

(* Procedures *)
procedure Throw(error : Error)
  e = make_error error;
  throw e
end

procedure RequireContractOwner()
  cur_owner <- contract_owner;
  is_contract_owner = builtin eq cur_owner _sender;
  match is_contract_owner with
  | True => 
  | False =>
    error = NotContractOwnerError;
    Throw error
  end
end

procedure RequireNotPaused()
  paused <- is_paused;
  match paused with
  | False =>
  | True =>
    (* Contract is paused *)
    error = PausedError;
    Throw error
  end
end

procedure RequirePaused()
  paused <- is_paused;
  match paused with
  | True =>
  | False =>
    (* Contract is paused *)
    error = NotPausedError;
    Throw error
  end
end

procedure RequireNotSelf(address: ByStr20)
  is_self = builtin eq address _sender;
  match is_self with
  | False =>
  | True =>
    error = SelfError;
    Throw error
  end
end

procedure Cancel(
  token_address: ByStr20 with contract 
    field royalty_recipient: ByStr20, 
    field royalty_fee_bps: Uint128, 
    field spenders: Map Uint256 ByStr20, 
    field token_owners: Map Uint256 ByStr20 
  end,
  token_id: Uint256,
  payment_token_address: ByStr20,
  sale_price: Uint128,
  side: Uint32,
  maker: ByStr20
  )
  is_sell_order = builtin eq side sell_side;
  match is_sell_order with 
  | True =>     
    delete sell_orders[token_address][token_id][payment_token_address][sale_price];
    e = {
      _eventname : "CancelOrder";
      maker: maker;
      side: side;
      token_address: token_address;
      token_id: token_id;
      payment_token_address: payment_token_address;
      sale_price: sale_price
    };
    event e
  | False => 
    delete buy_orders[token_address][token_id][payment_token_address][sale_price];
    e = {
      _eventname : "CancelOrder";
      maker: maker;
      side: side;
      token_address: token_address;
      token_id: token_id;
      payment_token_address: payment_token_address;
      sale_price: sale_price
    };
    event e
  end
end

procedure RequireNonZeroAddress(to: ByStr20)
  (* Reference: https://github.com/ConsenSys/smart-contract-best-practices/blob/master/docs/tokens.md *)
  is_zero_address = builtin eq to zero_address;
  match is_zero_address with
  | False =>
  | True =>
    error = ZeroAddressError;
    Throw error
  end
end

procedure RequireLogic()
  current_logic <- logic;
  RequireNonZeroAddress current_logic;
  is_logic = builtin eq current_logic _sender;
  match is_logic with
  | True =>
  | False =>
    error = NotOperatorError;
    Throw error
  end
end

(* Sets sell and buy orders. *)
(* - Sellers can set sell orders (listings) *)
(* - Buyers can set buy orders (offers) *)
transition SetOrder(
    token_address: ByStr20 with contract 
        field royalty_recipient: ByStr20, 
        field royalty_fee_bps: Uint128, 
        field spenders: Map Uint256 ByStr20, 
        field token_owners: Map Uint256 ByStr20 
    end,
    token_id: Uint256,
    payment_token_address: ByStr20,
    sale_price: Uint128,
    side: Uint32,
    expiration_bnum: BNum,
    sender: ByStr20
)
  RequireNotPaused;
  RequireLogic;
(*  order = OrderParam token_address token_id payment_token_address sale_price side expiration_bnum;*)
(*  DoSetOrder order*)
  
  is_sell_order = builtin eq side sell_side;
  match is_sell_order with 
  | True => 
    (* Side: Sell *)
    (* Only the token owner can create sell orders *)
    (* set new sell order *)
    new_order = Order sender expiration_bnum;
    sell_orders[token_address][token_id][payment_token_address][sale_price] := new_order;
    
    e = {
      _eventname : "SetOrder";
      maker: _sender;
      side: side;
      token_address: token_address;
      token_id: token_id;
      payment_token_address: payment_token_address;
      sale_price: sale_price;
      expiration_bnum: expiration_bnum
    };
    event e
  | False => 
    (* Side: Buy *)
    (* The token owner must not be able to create buy orders *)
    (* set new buy order *)
    new_order = Order sender expiration_bnum;

    buy_orders[token_address][token_id][payment_token_address][sale_price] := new_order;

    e = {
      _eventname : "SetOrder";
      maker: _sender;
      side: side;
      token_address: token_address;
      token_id: token_id;
      payment_token_address: payment_token_address;
      sale_price: sale_price;
      expiration_bnum: expiration_bnum
    };
    event e
  end
end

(* Fulfills orders *)
(* `dest` enables buyers to set an address to receive the asset when fulfilling a sell order. *)
(* `dest` is only meaningful for buyers at the moment *)
transition FulfillOrder(
  token_address: ByStr20 with contract 
    field royalty_recipient: ByStr20, 
    field royalty_fee_bps: Uint128, 
    field spenders: Map Uint256 ByStr20, 
    field token_owners: Map Uint256 ByStr20 
  end,
  token_id: Uint256,
  payment_token_address: ByStr20,
  sale_price: Uint128,
  side: Uint32,
  dest: ByStr20,
  buyer: ByStr20,
  seller: ByStr20
  )
  RequireNotPaused;
  RequireLogic;
  is_sell_order = builtin eq side sell_side;
  match is_sell_order with 
  | True =>
    delete sell_orders[token_address][token_id]
  | False =>
    delete sell_orders[token_address][token_id];
    delete buy_orders[token_address][token_id][payment_token_address][sale_price]
  end
end

(* @multi-sig *)
(* Cancels orders *)
transition CancelOrder(
  token_address: ByStr20 with contract 
    field royalty_recipient: ByStr20, 
    field royalty_fee_bps: Uint128, 
    field spenders: Map Uint256 ByStr20, 
    field token_owners: Map Uint256 ByStr20 
  end,
  token_id: Uint256,
  payment_token_address: ByStr20,
  sale_price: Uint128,
  side: Uint32,
  maker: ByStr20
)
  RequireLogic;
  Cancel token_address token_id payment_token_address sale_price side maker
end

(* @multi-sig *)
(* Pauses the contract. Use this when things are going wrong ('circuit breaker'). *)
transition Pause()
  RequireNotPaused;
  RequireContractOwner;
  is_paused := true;
  e = {
    _eventname: "Pause";
    source: "FPState";
    is_paused: true
  };
  event e
end

(* @multi-sig *)
(* Unpauses the contract. *)
transition Unpause()
  RequirePaused;
  RequireContractOwner;
  is_paused := false;
  e = {
    _eventname: "Unpause";
    source: "FPState";
    is_paused: false
  };
  event e
end

(* @multi-sig *)
transition AllowPaymentTokenAddress(address: ByStr20)
  RequireLogic;
  allowed_payment_tokens[address] := true;
  e = {
    _eventname : "AllowPaymentTokenAddress";
    source: "FPState";
    payment_token_address: address
  };
  event e
end

(* @multi-sig *)
transition DisallowPaymentTokenAddress(address: ByStr20)
  RequireLogic;
  delete allowed_payment_tokens[address];
  e = {
    _eventname : "DisallowPaymentTokenAddress";
    source: "FPState";
    payment_token_address: address
  };
  event e
end

(* @multi-sig *)
transition SetServiceFeeBPS(fee_bps: Uint128)
  RequireLogic;
  service_fee_bps := fee_bps;
  e = {
    _eventname : "SetServiceFeeBPS";
    source: "FPState";
    service_fee_bps: fee_bps
  };
  event e
end

(* @multi-sig *)
transition SetServiceFeeRecipient(to: ByStr20)
  RequireLogic;
  service_fee_recipient := to;
  e = { 
    _eventname: "SetServiceFeeRecipient";
    source: "FPState";
    to: to
  };
  event e
end

(* @multi-sig *)
transition ClearAllowList()
  RequireLogic;
  allowlist_address := zero_address;
  e = { 
    _eventname: "ClearAllowList";
    source: "FPState"
  };
  event e
end

(* @multi-sig *)
transition SetAllowlist(allowed_addresses: ByStr20)
  RequireLogic;
  allowlist_address := allowed_addresses;
  e = { 
    _eventname: "SetAllowlist";
    source: "FPState";
    address: allowed_addresses
  };
  event e
end

(* @multi-sig *)
transition UpdateCollectionContract(
  new_collection_address: ByStr20 with contract 
    field token_collection: Map ByStr20 (Map Uint256 Uint32),
    field collection_owning_brand: Map Uint32 ByStr20,
    field has_had_first_sale: Map ByStr20 (Map Uint256 Bool),
    field collection_commission_fee: Map Uint32 Uint128
  end
  )
  RequireLogic;
  collection_address := new_collection_address;
  e = { 
    _eventname: "UpdateCollectionContract";
    source: "FPState";
    address: new_collection_address
  };
  event e
end

(* @multi-sig *)
(* Address of the new logic contract *)
transition UpdateLogic(new_logic_contract: ByStr20)
  RequireNonZeroAddress new_logic_contract;
  RequireContractOwner;
  cur_bnum <- & BLOCKNUMBER;
  logic := new_logic_contract;
  e = { 
    _eventname: "LogicContractUpdated";
    address: new_logic_contract;
    source: "FPState";
    when: cur_bnum
  };
  event e
end

(* @multi-sig *)
(* Sets `to` as the contract ownership recipient. *)
(* To reset `contract_ownership_recipient`, use `zero_address`. *)
(* i.e., `0x0000000000000000000000000000000000000000` *)
transition SetContractOwnershipRecipient(to: ByStr20)
  RequireContractOwner;
  RequireNotSelf to;
  contract_ownership_recipient := to;
  e = {
    _eventname: "SetContractOwnershipRecipient";
    source: "FPState";
    to: to
  };
  event e
end

(* @multi-sig *)
(* Sets `contract_ownership_recipient` as the contract owner. *)
transition AcceptContractOwnership()
  recipient <- contract_ownership_recipient;
  is_recipient = builtin eq _sender recipient;
  match is_recipient with
  | False =>
    error = NotContractOwnershipRecipientError;
    Throw error
  | True =>
    contract_owner := _sender;
    contract_ownership_recipient := zero_address;
    e = {
      _eventname: "AcceptContractOwnership";
      source: "FPState";
      contract_owner: _sender
    };
    event e
  end
end