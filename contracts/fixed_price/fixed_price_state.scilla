(* SPDX-License-Identifier: GPL-3.0 *)
scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)
import BoolUtils IntUtils

library FixedPriceOrderbook_State

let zero_address = 0x0000000000000000000000000000000000000000
let false = False
let true = True
let one_uint32 = Uint32 1

(* Error exceptions *)
type Error =
  | NotContractOwnerError
  | SelfError
  | NotContractOwnershipRecipientError
  | ZeroAddressError
  | NotOperatorError
  
let make_error =
  fun (result : Error) =>
    let result_code = 
      match result with
      | NotContractOwnerError              => Int32 -1
      | SelfError                          => Int32 -2
      | NotContractOwnershipRecipientError => Int32 -3
      | ZeroAddressError                   => Int32 -4
      | NotOperatorError                   => Int32 -5
      end
    in
    { _exception : "Error"; source : "state"; code : result_code }

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract FixedPriceOrderbook_State
(
  initial_contract_owner: ByStr20,
  initial_collection_contract: ByStr20 with contract
    field token_collection: Map ByStr20 (Map Uint256 Uint32),
    field collection_owning_brand: Map Uint32 ByStr20,
    field has_had_first_sale: Map ByStr20 (Map Uint256 Bool),
    field collection_commission_fee: Map Uint32 Uint128
  end
)

(* Logic Contract Address  *)
field logic: ByStr20 = zero_address

field sell_side: Uint32 = Uint32 0

(* 
  A composite primary key of a sell order or buy order consists of
  - asset contract address (ZRC-6)
  - token ID
  - payment token contract address (ZRC-2)
  - sale price
*)

(* Allowlist Contract Address *)
(* Defaults to `zero_address` *)
field allowlist_address: ByStr20 = zero_address

(* Collection Contract Address *)
field collection_address: ByStr20 with contract
  field token_collection: Map ByStr20 (Map Uint256 Uint32),
  field collection_owning_brand: Map Uint32 ByStr20,
  field has_had_first_sale: Map ByStr20 (Map Uint256 Bool),
  field collection_commission_fee: Map Uint32 Uint128
end = initial_collection_contract

(* Contract Owner *)
(* Defaults to `initial_contract_owner` *)
field contract_owner: ByStr20 = initial_contract_owner

(* Contract ownership recipient *)
(* Defaults to `zero_address` *)
field contract_ownership_recipient: ByStr20 = zero_address

(* token_address -> ( token_id -> ( payment_token_address -> (sale_price -> sell_order  ) ) *)
field sell_orders: Map ByStr20 (Map Uint256 (Map ByStr20 (Map Uint128 Map ByStr20 BNum))) = Emp ByStr20 (Map Uint256 (Map ByStr20 (Map Uint128 Map ByStr20 BNum)))

(* token_address -> ( token_id -> ( payment_token_address -> (sale_price -> buy_order ) ) *)
field buy_orders: Map ByStr20 (Map Uint256 (Map ByStr20 (Map Uint128 Map ByStr20 BNum))) = Emp ByStr20 (Map Uint256 (Map ByStr20 (Map Uint128 Map ByStr20 BNum)))

(* There must be an allowlist for the payment tokens (ZRC-2) *)
field allowed_payment_tokens: Map ByStr20 Uint32 = Emp ByStr20 Uint32

(* service fee BPS (e.g. 250 = 2.5% *)
(* A marketplace may take service fee (x% of every transaction) and use basis points (BPS) for the fee.  *)
(* `service_fee_bps` must range from `1` to `10000`. *)
(* Defaults to 250 *)
field service_fee_bps: Uint128 = Uint128 250

field service_fee_recipient: ByStr20 = initial_contract_owner

(* Procedures *)
procedure Throw(error : Error)
  e = make_error error;
  throw e
end

procedure RequireContractOwner()
  cur_owner <- contract_owner;
  is_contract_owner = builtin eq cur_owner _sender;
  match is_contract_owner with
  | True => 
  | False =>
    error = NotContractOwnerError;
    Throw error
  end
end

procedure RequireNotSelf(address: ByStr20)
  is_self = builtin eq address _sender;
  match is_self with
  | False =>
  | True =>
    error = SelfError;
    Throw error
  end
end

procedure Cancel(
  token_address: ByStr20 with contract 
    field royalty_recipient: ByStr20, 
    field royalty_fee_bps: Uint128, 
    field spenders: Map Uint256 ByStr20, 
    field token_owners: Map Uint256 ByStr20 
  end,
  token_id: Uint256,
  payment_token_address: ByStr20,
  sale_price: Uint128,
  side: Uint32,
  maker: ByStr20
  )
  sell_side_ <- sell_side;
  is_sell_order = builtin eq side sell_side_;
  match is_sell_order with 
  | True =>     
    delete sell_orders[token_address][token_id][payment_token_address][sale_price]
  | False => 
    delete buy_orders[token_address][token_id][payment_token_address][sale_price]
  end
end

procedure RequireNonZeroAddress(to: ByStr20)
  (* Reference: https://github.com/ConsenSys/smart-contract-best-practices/blob/master/docs/tokens.md *)
  is_zero_address = builtin eq to zero_address;
  match is_zero_address with
  | False =>
  | True =>
    error = ZeroAddressError;
    Throw error
  end
end

procedure RequireLogic()
  current_logic <- logic;
  RequireNonZeroAddress current_logic;
  is_logic = builtin eq current_logic _sender;
  match is_logic with
  | True =>
  | False =>
    error = NotOperatorError;
    Throw error
  end
end

(* Sets sell and buy orders. *)
(* - Sellers can set sell orders (listings) *)
(* - Buyers can set buy orders (offers) *)
transition SetOrder(
    token_address: ByStr20 with contract 
        field royalty_recipient: ByStr20, 
        field royalty_fee_bps: Uint128, 
        field spenders: Map Uint256 ByStr20, 
        field token_owners: Map Uint256 ByStr20 
    end,
    token_id: Uint256,
    payment_token_address: ByStr20,
    sale_price: Uint128,
    side: Uint32,
    expiration_bnum: BNum,
    sender: ByStr20
)
  RequireLogic;
  sell_side_ <- sell_side;
  is_sell_order = builtin eq side sell_side_;
  match is_sell_order with 
  | True => 
    (* Side: Sell *)
    (* Only the token owner can create sell orders *)
    (* set new sell order *)
    sell_orders[token_address][token_id][payment_token_address][sale_price][sender] := expiration_bnum
  | False => 
    (* Side: Buy *)
    (* The token owner must not be able to create buy orders *)
    (* set new buy order *)
    buy_orders[token_address][token_id][payment_token_address][sale_price][sender] := expiration_bnum
  end
end

(* Fulfills orders *)
(* `dest` enables buyers to set an address to receive the asset when fulfilling a sell order. *)
(* `dest` is only meaningful for buyers at the moment *)
transition FulfillOrder(
  token_address: ByStr20 with contract 
    field royalty_recipient: ByStr20, 
    field royalty_fee_bps: Uint128, 
    field spenders: Map Uint256 ByStr20, 
    field token_owners: Map Uint256 ByStr20 
  end,
  token_id: Uint256,
  payment_token_address: ByStr20,
  sale_price: Uint128,
  side: Uint32
  )
  RequireLogic;
  sell_side_ <- sell_side;
  is_sell_order = builtin eq side sell_side_;
  match is_sell_order with 
  | True =>
    delete sell_orders[token_address][token_id]
  | False =>
    delete sell_orders[token_address][token_id];
    delete buy_orders[token_address][token_id]
  end
end

(* @multi-sig *)
(* Cancels orders *)
transition CancelOrder(
  token_address: ByStr20 with contract 
    field royalty_recipient: ByStr20, 
    field royalty_fee_bps: Uint128, 
    field spenders: Map Uint256 ByStr20, 
    field token_owners: Map Uint256 ByStr20 
  end,
  token_id: Uint256,
  payment_token_address: ByStr20,
  sale_price: Uint128,
  side: Uint32,
  maker: ByStr20
)
  RequireLogic;
  Cancel token_address token_id payment_token_address sale_price side maker
end

(* @multi-sig *)
(* if accepted pass 1 *)
transition AllowPaymentTokenAddress(address: ByStr20)
  RequireContractOwner;
  allowed_payment_tokens[address] := one_uint32;
  e = {
    _eventname : "AllowPaymentTokenAddress";
    payment_token_address: address
  };
  event e
end

(* @multi-sig *)
transition DisallowPaymentTokenAddress(address: ByStr20)
  RequireContractOwner;
  delete allowed_payment_tokens[address];
  e = {
    _eventname : "DisallowPaymentTokenAddress";
    payment_token_address: address
  };
  event e
end

(* @multi-sig *)
transition SetServiceFeeBPS(fee_bps: Uint128)
  RequireContractOwner;
  service_fee_bps := fee_bps;
  e = {
    _eventname : "SetServiceFeeBPS";
    service_fee_bps: fee_bps
  };
  event e
end

(* @multi-sig *)
transition SetServiceFeeRecipient(to: ByStr20)
  RequireContractOwner;
  service_fee_recipient := to;
  e = { 
    _eventname: "SetServiceFeeRecipient";
    to: to
  };
  event e
end

(* @multi-sig *)
transition ClearAllowList()
  RequireContractOwner;
  allowlist_address := zero_address;
  e = { 
    _eventname: "ClearAllowList"
  };
  event e
end

(* @multi-sig *)
transition SetAllowlist(address: ByStr20)
  RequireContractOwner;
  allowlist_address := address;
  e = { 
    _eventname: "SetAllowlist";
    address: address
  };
  event e
end

(* @multi-sig *)
transition UpdateCollectionContract(
  new_collection_address: ByStr20 with contract 
    field token_collection: Map ByStr20 (Map Uint256 Uint32),
    field collection_owning_brand: Map Uint32 ByStr20,
    field has_had_first_sale: Map ByStr20 (Map Uint256 Bool),
    field collection_commission_fee: Map Uint32 Uint128
  end
  )
  RequireContractOwner;
  collection_address := new_collection_address;
  e = { 
    _eventname: "UpdateCollectionContract";
    address: new_collection_address
  };
  event e
end

(* @multi-sig *)
(* Address of the new logic contract *)
transition UpdateLogic(new_logic_contract: ByStr20)
  RequireNonZeroAddress new_logic_contract;
  RequireContractOwner;
  cur_bnum <- & BLOCKNUMBER;
  logic := new_logic_contract;
  e = { 
    _eventname: "LogicContractUpdated";
    address: new_logic_contract;
    when: cur_bnum
  };
  event e
end

(* @multi-sig *)
(* Sets `to` as the contract ownership recipient. *)
(* To reset `contract_ownership_recipient`, use `zero_address`. *)
(* i.e., `0x0000000000000000000000000000000000000000` *)
transition SetContractOwnershipRecipient(to: ByStr20)
  RequireContractOwner;
  RequireNotSelf to;
  contract_ownership_recipient := to;
  e = {
    _eventname: "SetContractOwnershipRecipient";
    source: "FPState";
    to: to
  };
  event e
end

(* @multi-sig *)
(* Sets `contract_ownership_recipient` as the contract owner. *)
transition AcceptContractOwnership()
  recipient <- contract_ownership_recipient;
  is_recipient = builtin eq _sender recipient;
  match is_recipient with
  | False =>
    error = NotContractOwnershipRecipientError;
    Throw error
  | True =>
    contract_owner := _sender;
    contract_ownership_recipient := zero_address;
    e = {
      _eventname: "AcceptContractOwnership";
      source: "FPState";
      contract_owner: _sender
    };
    event e
  end
end